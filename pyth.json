{
  "testSnippet": {
    "prefix": "test",
    "body": ["print('Hello, Snippet!')"],
    "description": "Test snippet"
  },
  "bfs": {
    "prefix": "bfs",
    "body": [
      "from collections import deque",
      "class GoalBasedAgent:",
      "    def __init__(self, goal):",
      "        self.goal = goal",
      "    def formulate_goal(self, percept):",
      "        return \"Goal reached\" if percept == self.goal else \"Searching\"",
      "    def bfs_search(self, graph, start, goal):",
      "        visited = set()",
      "        queue = deque([start])",
      "        visited.add(start)",
      "        while queue:",
      "            node = queue.popleft()",
      "            print(f\"Visiting: {node}\")",
      "            if node == goal:",
      "                return f\"Goal {goal} found!\"",
      "            for neighbour in graph.get(node, []):",
      "                if neighbour not in visited:",
      "                    visited.add(neighbour)",
      "                    queue.append(neighbour)",
      "        return \"Goal not found\"",
      "    def act(self, percept, graph):",
      "        return f\"Goal {self.goal} found!\" if self.formulate_goal(percept) == \"Goal reached\" else self.bfs_search(graph, percept, self.goal)"
    ],
    "description": "BFS implementation using deque"
  },
  "dfs": {
    "prefix": "dfs",
    "body": [
      "from collections import deque",
      "class GoalBasedAgent:",
      "    def __init__(self, goal):",
      "        self.goal = goal",
      "    def formulate_goal(self, percept):",
      "        return \"Goal reached\" if percept == self.goal else \"Searching\"",
      "    def dfs_search(self, graph, start, goal):",
      "        visited = set()",
      "        stack = deque([start])",
      "        visited.add(start)",
      "        while stack:",
      "            node = stack.pop()",
      "            print(f\"Visiting: {node}\")",
      "            if node == goal:",
      "                return f\"Goal {goal} found!\"",
      "            for neighbour in reversed(graph.get(node, [])):",
      "                if neighbour not in visited:",
      "                    visited.add(neighbour)",
      "                    stack.append(neighbour)",
      "        return \"Goal not found\"",
      "    def act(self, percept, graph):",
      "        return f\"Goal {self.goal} found!\" if self.formulate_goal(percept) == \"Goal reached\" else self.dfs_search(graph, percept, self.goal)"
    ],
    "description": "DFS implementation using deque"
  },
  "recdfs": {
    "prefix": "recdfs",
    "body": [
      "def recdfs(graph, node, goal, visited=None, path=None):",
      "    if visited is None:",
      "        visited = set()",
      "    if path is None:",
      "        path = []",
      "    visited.add(node)",
      "    path.append(node)",
      "    print(\" -> \".join(path))",
      "    if node == goal:",
      "        print(\"\\nGoal Node Found Path:\", \" -> \".join(path))",
      "        return True",
      "    for neighbor in graph.get(node, []):",
      "        if neighbor not in visited:",
      "            if recdfs(graph, neighbor, goal, visited, path):",
      "                return True",
      "    path.pop()",
      "    return False"
    ],
    "description": "Recursive DFS implementation"
  },

  "dlsgoal": {
    "prefix": "dls",
    "body": [
      "def dls(graph, start, goal, depth_limit):",
      "    visited = []",
      "    stack = [(start, 0)]",
      "    visited.append(start)",
      "    while stack:",
      "        node, depth = stack.pop()",
      "        print(node, end=\" \")",
      "        if node == goal:",
      "            print(\"\\nGoal found!\")",
      "            return True",
      "        if depth < depth_limit:",
      "            for neighbour in reversed(graph.get(node, [])):",
      "                if neighbour not in visited:",
      "                    visited.append(neighbour)",
      "                    stack.append((neighbour, depth + 1))",
      "    return False",
      "class GoalBasedAgent:",
      "    def __init__(self, goal, depth_limit):",
      "        self.goal = goal",
      "        self.depth_limit = depth_limit",
      "    def formulate_goal(self, percept):",
      "        return \"Goal reached\" if percept == self.goal else \"Searching\"",
      "    def dls_search(self, graph, start, goal, depth_limit):",
      "        visited = []",
      "        stack = [(start, 0)]",
      "        visited.append(start)",
      "        while stack:",
      "            node, depth = stack.pop()",
      "            print(f\"Visiting: {node}, Depth: {depth}\")",
      "            if node == goal:",
      "                return f\"Goal {goal} found!\"",
      "            if depth < depth_limit:",
      "                for neighbour in reversed(graph.get(node, [])):",
      "                    if neighbour not in visited:",
      "                        visited.append(neighbour)",
      "                        stack.append((neighbour, depth + 1))",
      "        return \"Goal not found\"",
      "    def act(self, percept, graph):",
      "        return f\"Goal {self.goal} found!\" if self.formulate_goal(percept) == \"Goal reached\" else self.dls_search(graph, percept, self.goal, self.depth_limit)",
      "class Environment:",
      "    def __init__(self, graph):",
      "        self.graph = graph",
      "    def get_percept(self, node):",
      "        return node"
    ],
    "description": "Depth-Limited Search (DLS) implementation"
  },

  "dfsgoal": {
    "prefix": "dfs",
    "body": [
      "class GoalBasedAgent:",
      "    def __init__(self, goal):",
      "        self.goal = goal",
      "    def formulate_goal(self, percept):",
      "        return \"Goal reached\" if percept == self.goal else \"Searching\"",
      "    def dfs_search(self, graph, start, goal):",
      "        visited = set()",
      "        stack = [start]",
      "        visited.add(start)",
      "        while stack:",
      "            node = stack.pop()",
      "            if node == goal:",
      "                return f\"Goal {goal} found!\"",
      "            for neighbour in reversed(graph.get(node, [])):",
      "                if neighbour not in visited:",
      "                    visited.add(neighbour)",
      "                    stack.append(neighbour)",
      "        return \"Goal not found\"",
      "    def act(self, percept, graph):",
      "        return f\"Goal {self.goal} found!\" if self.formulate_goal(percept) == \"Goal reached\" else self.dfs_search(graph, percept, self.goal)"
    ],
    "description": "Depth-First Search (DFS) implementation"
  },
  "iterative_dls": {
    "prefix": "dls",
    "body": [
      "def dlss(node, goal, depth, path, tree):",
      "    if node == goal:",
      "        path.append(goal)",
      "        return True",
      "    if depth == 0 or node not in tree:",
      "        return False",
      "    for child in tree[node]:",
      "        if dlss(child, goal, depth - 1, path, tree):",
      "            path.append(node)",
      "            return True",
      "    return False",
      "",
      "def iterative_deepening(start, goal, max_depth, tree):",
      "    for depth in range(max_depth + 1):",
      "        path = []",
      "        if dlss(start, goal, depth, path, tree):",
      "            print(' -> '.join(reversed(path)))",
      "            return",
      "    print('Goal not found')"
    ],
    "description": "Depth-Limited Search and Iterative Deepening"
  },

  "bfs_maze": {
    "prefix": "bfs_maze",
    "body": [
      "from collections import deque",
      "directions = [(0, 1), (1, 0)]",
      "def create_graph(maze):",
      "    graph = {}",
      "    rows, cols = len(maze), len(maze[0])",
      "    for i in range(rows):",
      "        for j in range(cols):",
      "            if maze[i][j] == 1:",
      "                neighbors = []",
      "                for dx, dy in directions:",
      "                    nx, ny = i + dx, j + dy",
      "                    if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] == 1:",
      "                        neighbors.append((nx, ny))",
      "                graph[(i, j)] = neighbors",
      "    return graph",
      "",
      "def bfs(graph, start, goal):",
      "    queue = deque([(start, [start])])",
      "    visited = set()",
      "    while queue:",
      "        node, path = queue.popleft()",
      "        if node == goal:",
      "            return path",
      "        if node not in visited:",
      "            visited.add(node)",
      "            for neighbor in graph.get(node, []):",
      "                queue.append((neighbor, path + [neighbor]))",
      "    return None"
    ],
    "description": "BFS for maze traversal"
  },

  "topological_sort": {
    "prefix": "topo_sort",
    "body": [
      "import heapq",
      "class MinQueue:",
      "    def __init__(self):",
      "        self.heap = []",
      "    def push(self, val):",
      "        heapq.heappush(self.heap, val)",
      "    def pop(self):",
      "        return heapq.heappop(self.heap) if self.heap else None",
      "    def peek(self):",
      "        return self.heap[0] if self.heap else None",
      "    def is_empty(self):",
      "        return len(self.heap) == 0",
      "    def size(self):",
      "        return len(self.heap)",
      "",
      "def topological_sort(tasks):",
      "    task_map = {task.name: task for task in tasks}",
      "    queue = MinQueue()",
      "    for task in tasks:",
      "        if task.in_degree == 0:",
      "            queue.push(task)",
      "    sorted_tasks = []",
      "    while not queue.is_empty():",
      "        current = queue.pop()",
      "        sorted_tasks.append(current.name)",
      "        for next_task in current.next_tasks:",
      "            next_task.in_degree -= 1",
      "            if next_task.in_degree == 0:",
      "                queue.push(next_task)",
      "    return sorted_tasks if len(sorted_tasks) == len(tasks) else \"Cycle detected\""
    ],
    "description": "Topological sorting using MinQueue"
  },
  "best_first_search": {
    "prefix": "best_fs",
    "body": [
      "from queue import PriorityQueue",
      "def best_first_search(graph, start, goal):",
      "    visited = set()",
      "    pq = PriorityQueue()",
      "    pq.put((0, start))",
      "    while not pq.empty():",
      "        cost, node = pq.get()",
      "        if node not in visited:",
      "            print(node, end=' ')",
      "            visited.add(node)",
      "            if node == goal:",
      "                print(\"\\nGoal Reached\")",
      "                return True",
      "        for neighbor, weight in graph.get(node, []):",
      "            if neighbor not in visited:",
      "                pq.put((weight, neighbor))",
      "    print(\"\\nGoal Not Reachable\")",
      "    return False"
    ],
    "description": "Best-First Search Algorithm"
  },
  "best_first_search_maze": {
    "prefix": "best_fs_maze",
    "body": [
      "from queue import PriorityQueue",
      "",
      "class Node:",
      "    def __init__(self, position, parent=None):",
      "        self.position = position",
      "        self.parent = parent",
      "        self.g = 0",
      "        self.h = 0",
      "        self.f = 0",
      "",
      "    def __lt__(self, other):",
      "        return self.f < other.f",
      "",
      "def heuristic(current_pos, end_pos):",
      "    return abs(current_pos[0] - end_pos[0]) + abs(current_pos[1] - end_pos[1])",
      "",
      "def best_first_search(maze, start, end):",
      "    rows, cols = len(maze), len(maze[0])",
      "    start_node = Node(start)",
      "    end_node = Node(end)",
      "    frontier = PriorityQueue()",
      "    frontier.put(start_node)",
      "    visited = set()",
      "",
      "    while not frontier.empty():",
      "        current_node = frontier.get()",
      "        current_pos = current_node.position",
      "",
      "        if current_pos == end:",
      "            path = []",
      "            while current_node:",
      "                path.append(current_node.position)",
      "                current_node = current_node.parent",
      "            return path[::-1]",
      "",
      "        visited.add(current_pos)",
      "",
      "        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "            new_pos = (current_pos[0] + dx, current_pos[1] + dy)",
      "            if (0 <= new_pos[0] < rows and 0 <= new_pos[1] < cols and maze[new_pos[0]][new_pos[1]] == 0 and new_pos not in visited):",
      "                new_node = Node(new_pos, current_node)",
      "                new_node.h = heuristic(new_pos, end)",
      "                new_node.f = new_node.h",
      "                frontier.put(new_node)",
      "                visited.add(new_pos)",
      "",
      "    return None"
    ],
    "description": "Best-First Search for Maze Navigation"
  },
  "a_star_search": {
    "prefix": "a_star",
    "body": [
      "from queue import PriorityQueue",
      "",
      "def a_star(graph, start, goal, heuristic):",
      "    frontier = PriorityQueue()",
      "    frontier.put((0 + heuristic[start], start))",
      "    visited = set()",
      "    g_costs = {start: 0}",
      "    came_from = {start: None}",
      "",
      "    while not frontier.empty():",
      "        current_f, current_node = frontier.get()",
      "        if current_node in visited:",
      "            continue",
      "        print(current_node, end=\" \")",
      "        visited.add(current_node)",
      "",
      "        if current_node == goal:",
      "            path = []",
      "            while current_node is not None:",
      "                path.append(current_node)",
      "                current_node = came_from[current_node]",
      "            path.reverse()",
      "            print(f\"\\nGoal Found with A* path: {path}\")",
      "            return path",
      "",
      "        for neighbor, cost in graph[current_node].items():",
      "            new_g_cost = g_costs[current_node] + cost",
      "            f_cost = new_g_cost + heuristic[neighbor]",
      "            if neighbor not in g_costs or new_g_cost < g_costs[neighbor]:",
      "                g_costs[neighbor] = new_g_cost",
      "                came_from[neighbor] = current_node",
      "                frontier.put((f_cost, neighbor))",
      "",
      "    print(\"\\nNo path found.\")",
      "    return None"
    ],
    "description": "A* Search Algorithm for Graph Traversal"
  },

  "astar_maze": {
    "prefix": "astar_maze",
    "body": [
      "from queue import PriorityQueue",
      "",
      "def astar(maze, start, goal):",
      "    directions = [(0,1), (1,0), (-1,0), (0,-1)]",
      "    def heuristic(ind):",
      "        return abs(ind[0] - goal[0]) + abs(ind[1] - goal[1])",
      "",
      "    queue = PriorityQueue()",
      "    queue.put((0 + heuristic(start), start))",
      "    visited = set()",
      "    g_costs = {start: 0}",
      "    came_from = {start: None}",
      "    rows, cols = len(maze), len(maze[0])",
      "",
      "    while not queue.empty():",
      "        _, current = queue.get()",
      "        if current == goal:",
      "            path = []",
      "            while current:",
      "                path.append(current)",
      "                current = came_from[current]",
      "            return path[::-1], g_costs[goal]",
      "",
      "        visited.add(current)",
      "",
      "        for dx, dy in directions:",
      "            nx, ny = current[0] + dx, current[1] + dy",
      "            if 0 <= nx < rows and 0 <= ny < cols and maze[nx][ny] != \"#\":",
      "                movement_cost = int(maze[nx][ny])",
      "                new_g = g_costs[current] + movement_cost",
      "                if (nx, ny) not in g_costs or new_g < g_costs[(nx, ny)]:",
      "                    g_costs[(nx, ny)] = new_g",
      "                    came_from[(nx, ny)] = current",
      "                    f = new_g + heuristic((nx, ny))",
      "                    queue.put((f, (nx, ny)))",
      "    return None"
    ],
    "description": "A* Search Algorithm for pathfinding in a maze"
  },
  "beam_search": {
    "prefix": "beam_search",
    "body": [
      "import heapq",
      "",
      "def beam_search(start, goal, beam_width=2):",
      "    beam = [(0, [start])]",
      "    while beam:",
      "        candidates = []",
      "        for cost, path in beam:",
      "            current_node = path[-1]",
      "            if current_node == goal:",
      "                return path, cost",
      "            for neighbor, edge_cost in graph.get(current_node, []):",
      "                new_cost = cost + edge_cost",
      "                new_path = path + [neighbor]",
      "                candidates.append((new_cost, new_path))",
      "        beam = heapq.nsmallest(beam_width, candidates, key=lambda x: x[0])",
      "    return None, float('inf')",
      "",
      "start_node = 'S'",
      "goal_node = 'L'",
      "beam_width = 3",
      "path, cost = beam_search(start=start_node, goal=goal_node, beam_width=beam_width)",
      "if path:",
      "    print(f\"Path found: {' → '.join(path)} with total cost: {cost}\")",
      "else:",
      "    print(\"No path found.\")"
    ],
    "description": "Beam Search Algorithm for pathfinding with limited beam width"
  },
  "simple_hill_climbing": {
    "prefix": "hill_climbing",
    "body": [
      "import random",
      "",
      "def calculate_conflicts(state):",
      "    conflicts = 0",
      "    n = len(state)",
      "    for i in range(n):",
      "        for j in range(i + 1, n):",
      "            if state[i] == state[j] or abs(state[i] - state[j]) == abs(i - j):",
      "                conflicts += 1",
      "    return conflicts",
      "",
      "def get_neighbors(state):",
      "    neighbors = []",
      "    n = len(state)",
      "    for row in range(n):",
      "        for col in range(n):",
      "            if col != state[row]:",
      "                new_state = list(state)",
      "                new_state[row] = col",
      "                neighbors.append(new_state)",
      "    return neighbors",
      "",
      "def simple_hill_climbing(n, max_restarts=100):",
      "    for _ in range(max_restarts):",
      "        current_state = [random.randint(0, n - 1) for _ in range(n)]",
      "        current_conflicts = calculate_conflicts(current_state)",
      "",
      "        while True:",
      "            neighbors = get_neighbors(current_state)",
      "            best_neighbor = None",
      "            best_conflicts = current_conflicts",
      "",
      "            for neighbor in neighbors:",
      "                neighbor_conflicts = calculate_conflicts(neighbor)",
      "                if neighbor_conflicts < best_conflicts:",
      "                    best_neighbor = neighbor",
      "                    best_conflicts = neighbor_conflicts",
      "",
      "            if best_conflicts == 0:",
      "                return best_neighbor",
      "",
      "            if best_neighbor is None:",
      "                break",
      "",
      "            current_state = best_neighbor",
      "            current_conflicts = best_conflicts",
      "",
      "    return None",
      "",
      "solution = simple_hill_climbing(4)",
      "if solution:",
      "    print(\"Solution found:\", solution)",
      "else:",
      "    print(\"No solution found.\")"
    ],
    "description": "Hill Climbing Algorithm for solving N-Queens Problem"
  },
  "genetic_algorithm_nqueens": {
    "prefix": "genetic_nqueens",
    "body": [
      "import random",
      "",
      "def calculate_fitness(individual, n):",
      "    non_attacking_pairs = 0",
      "    total_pairs = n * (n - 1) // 2",
      "    for i in range(n):",
      "        for j in range(i + 1, n):",
      "            if individual[i] != individual[j] and abs(",
      "                individual[i] - individual[j]",
      "            ) != abs(i - j):",
      "                non_attacking_pairs += 1",
      "    return non_attacking_pairs / total_pairs",
      "",
      "def create_random_individual(n):",
      "    return random.sample(range(n), n)",
      "",
      "def select_parent(population, fitness_scores):",
      "    sorted_population = [",
      "        board for _, board in sorted(zip(fitness_scores, population), reverse=True)",
      "    ]",
      "    return sorted_population[: len(population) // 2]",
      "",
      "def crossover(parent1, parent2, n):",
      "    point = random.randint(1, n - 2)",
      "    child = parent1[:point] + parent2[point:]",
      "    missing = set(range(n)) - set(child)",
      "    for i in range(len(child)):",
      "        if child.count(child[i]) > 1:",
      "            child[i] = missing.pop()",
      "    return child",
      "",
      "def mutate(individual, n):",
      "    idx1, idx2 = random.sample(range(n), 2)",
      "    individual[idx1], individual[idx2] = individual[idx2], individual[idx1]",
      "    return individual",
      "",
      "def genetic_algorithm(",
      "    n,",
      "    population_size=10,",
      "    mutation_rate=0.1,",
      "    max_generations=100,",
      "    fitness_threshold=0.001,",
      "):",
      "    population = [create_random_individual(n) for _ in range(population_size)]",
      "    generation = 0",
      "    best_fitness = 0",
      "    prev_best_fitness = 0",
      "",
      "    while best_fitness < 1.0 and generation < max_generations:",
      "        fitness_scores = [calculate_fitness(ind, n) for ind in population]",
      "        best_fitness = max(fitness_scores)",
      "",
      "        if abs(best_fitness - prev_best_fitness) < fitness_threshold:",
      "            break",
      "",
      "        prev_best_fitness = best_fitness",
      "        parents = select_parent(population, fitness_scores)",
      "",
      "        new_population = [",
      "            crossover(random.choice(parents), random.choice(parents), n)",
      "            for _ in range(population_size)",
      "        ]",
      "",
      "        for i in range(len(new_population)):",
      "            if random.random() < mutation_rate:",
      "                new_population[i] = mutate(new_population[i], n)",
      "",
      "        population = new_population",
      "        generation += 1",
      "",
      "    best_individual = max(population, key=lambda ind: calculate_fitness(ind, n))",
      "    return best_individual, calculate_fitness(best_individual, n)"
    ],
    "description": "Genetic Algorithm for solving N-Queens Problem"
  },
  "beam_search_maze": {
    "prefix": "beam_search",
    "body": [
      "import heapq",
      "",
      "def beam_search(maze, start, end, beam_width):",
      "    rows, cols = len(maze), len(maze[0])",
      "    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]",
      "",
      "    def heuristic(p):",
      "        return abs(p[0] - end[0]) + abs(p[1] - end[1])",
      "    ",
      "    queue = [(heuristic(start), [start])]",
      "    visited = set()",
      "",
      "    while queue:",
      "        queue = heapq.nsmallest(beam_width, queue)",
      "        new_queue = []",
      "        ",
      "        for _, path in queue:",
      "            current = path[-1]",
      "            if current == end:",
      "                return path, len(path) - 1",
      "            ",
      "            for move in moves:",
      "                next_pos = (current[0] + move[0], current[1] + move[1])",
      "                ",
      "                if (0 <= next_pos[0] < rows and 0 <= next_pos[1] < cols and",
      "                        maze[next_pos[0]][next_pos[1]] == 0 and next_pos not in visited):",
      "                    ",
      "                    visited.add(next_pos)",
      "                    new_path = path + [next_pos]",
      "                    new_queue.append((heuristic(next_pos), new_path))",
      "        ",
      "        queue = new_queue",
      "",
      "    return None, -1",
      "",
      "maze = [",
      "    [0, 1, 0, 0, 0],",
      "    [0, 1, 0, 1, 0],",
      "    [0, 0, 0, 1, 0],",
      "    [1, 1, 0, 0, 0],",
      "    [0, 0, 0, 1, 0]",
      "]",
      "",
      "start = (0, 0)",
      "end = (4, 4)",
      "beam_width = 2",
      "",
      "path, steps = beam_search(maze, start, end, beam_width)",
      "print(\"Path:\", path)",
      "print(\"Steps Taken:\", steps)"
    ],
    "description": "Beam Search Algorithm for Pathfinding in a Maze"
  },
  "genetic_algorithm_scheduling": {
    "prefix": "genetic_scheduling",
    "body": [
      "import random",
      "",
      "num_staff = 5",
      "num_shifts = 21",
      "max_shifts_per_staff = 7",
      "required_staff_per_shift = 2",
      "population_size = 10",
      "mutation_rate = 0.1",
      "max_generations = 10000",
      "",
      "def evaluate_fitness(schedule):",
      "    penalty = 0",
      "    for shift in range(num_shifts):",
      "        assigned_count = sum(schedule[staff][shift] for staff in range(num_staff))",
      "        if assigned_count < required_staff_per_shift:",
      "            penalty += (required_staff_per_shift - assigned_count) * 10",
      "",
      "    for staff in range(num_staff):",
      "        for shift in range(num_shifts - 1):",
      "            if schedule[staff][shift] == 1 and schedule[staff][shift + 1] == 1:",
      "                penalty += 5",
      "    return penalty",
      "",
      "def create_random_schedule():",
      "    schedule = [[0] * num_shifts for _ in range(num_staff)]",
      "    for staff in range(num_staff):",
      "        assigned_shifts = random.sample(range(num_shifts), random.randint(3, max_shifts_per_staff))",
      "        for shift in assigned_shifts:",
      "            schedule[staff][shift] = 1",
      "    return schedule",
      "",
      "def select_parent(population, fitness_scores):",
      "    sorted_population = [x for _, x in sorted(zip(fitness_scores, population))]",
      "    return sorted_population[:len(population) // 2]",
      "",
      "def crossover(parent1, parent2):",
      "    point = random.randint(0, num_shifts - 1)",
      "    child = [parent1[i][:point] + parent2[i][point:] for i in range(num_staff)]",
      "    return child",
      "",
      "def mutate(schedule):",
      "    staff = random.randint(0, num_staff - 1)",
      "    shift1, shift2 = random.sample(range(num_shifts), 2)",
      "    schedule[staff][shift1], schedule[staff][shift2] = schedule[staff][shift2], schedule[staff][shift1]",
      "    return schedule",
      "",
      "population = [create_random_schedule() for _ in range(population_size)]",
      "",
      "for generation in range(max_generations):",
      "    fitness_scores = [evaluate_fitness(schedule) for schedule in population]",
      "    best_fitness = min(fitness_scores)",
      "    print(f\"Generation {generation+1} Best Fitness: {best_fitness}\")",
      "",
      "    if best_fitness == 0:",
      "        break",
      "",
      "    parents = select_parent(population, fitness_scores)",
      "    new_population = []",
      "",
      "    while len(new_population) < population_size:",
      "        parent1, parent2 = random.sample(parents, 2)",
      "        child = crossover(parent1, parent2)",
      "        if random.random() < mutation_rate:",
      "            child = mutate(child)",
      "        new_population.append(child)",
      "",
      "    population = new_population",
      "",
      "best_index = fitness_scores.index(min(fitness_scores))",
      "best_schedule = population[best_index]",
      "",
      "print(\"\\nBest Schedule (Staff x Shifts):\")",
      "for staff in range(num_staff):",
      "    print(f\"Staff {staff + 1}: {best_schedule[staff]}\")"
    ],
    "description": "Genetic Algorithm for Employee Shift Scheduling"
  },
  "knapsack_ga": {
    "prefix": "knapsack_ga",
    "body": [
      "import random",
      "",
      "def knapsack_ga(values, weights, capacity, population_size=10, generation=100, mutation_ratio=0.1):",
      "    num_items = len(values)",
      "",
      "    def random_chromosomes():",
      "        return [random.choice([0, 1]) for _ in range(num_items)]",
      "",
      "    def fitness(chromosomes):",
      "        total_value = sum(v * c for v, c in zip(values, chromosomes))",
      "        total_weight = sum(w * c for w, c in zip(weights, chromosomes))",
      "        return total_value if total_weight <= capacity else 0",
      "",
      "    def select(population):",
      "        tournament = random.sample(population, k=5)",
      "        return max(tournament, key=fitness)",
      "",
      "    def crossover(parent1, parent2):",
      "        point = random.randint(1, num_items - 1)",
      "        return parent1[:point] + parent2[point:], parent2[:point] + parent1[point:]",
      "",
      "    def mutate(chromosome):",
      "        return [bit if random.random() > mutation_ratio else 1 - bit for bit in chromosome]",
      "",
      "    population = [random_chromosomes() for _ in range(population_size)]",
      "",
      "    for _ in range(generation):",
      "        population = sorted(population, key=fitness, reverse=True)[:population_size]",
      "        new_population = []",
      "",
      "        while len(new_population) < population_size:",
      "            parent1, parent2 = select(population), select(population)",
      "            offspring1, offspring2 = crossover(parent1, parent2)",
      "            new_population.extend([mutate(offspring1), mutate(offspring2)])",
      "",
      "        population = new_population[:population_size]",
      "        best_chromosomes = max(population, key=fitness)",
      "        best_value = fitness(best_chromosomes)",
      "        selected_items = [i for i, bit in enumerate(best_chromosomes) if bit == 1]",
      "        return selected_items, best_value",
      "",
      "values = [900, 100, 120, 30, 50, 90]",
      "weights = [10, 20, 30, 5, 15, 25]",
      "capacity = 50",
      "",
      "best_items, best_value = knapsack_ga(values, weights, capacity)",
      "print(\"Selected Items:\", best_items)",
      "print(\"Total Value:\", best_value)"
    ],
    "description": "Genetic Algorithm for the Knapsack Problem"
  },
  "book_arrangement_ga": {
    "prefix": "book_ga",
    "body": [
      "import random",
      "",
      "books=[2,5,3,7,1,4,6]",
      "POP_SIZE=10",
      "GENERATIONS=50",
      "MUTATION_RATE=0.2",
      "restricted_pair = [(2, 3), (5, 7)]",
      "",
      "def initial_population():",
      "    return [random.sample(books, len(books)) for _ in range(POP_SIZE)]",
      "",
      "def fitness(arrangement):",
      "    penalty = 0",
      "    for i in range(len(arrangement) - 1):",
      "        if (arrangement[i], arrangement[i+1]) in restricted_pair or (arrangement[i+1], arrangement[i]) in restricted_pair:",
      "            penalty += 10",
      "    return sum(arrangement) + penalty",
      "",
      "def roulette_wheel_selection(pop):",
      "    fitness_values = [1 / fitness(ind) for ind in pop]",
      "    total_fitness = sum(fitness_values)",
      "    probabilities = [f / total_fitness for f in fitness_values]",
      "    return random.choices(pop, probabilities, k=2)",
      "",
      "def crossover(parent1, parent2):",
      "    point = random.randint(1, len(parent1) - 2)",
      "    child1 = parent1[:point] + [b for b in parent2 if b not in parent1[:point]]",
      "    child2 = parent2[:point] + [b for b in parent1 if b not in parent2[:point]]",
      "    return child1, child2",
      "",
      "def mutate(individual):",
      "    if random.random() < MUTATION_RATE:",
      "        i, j = random.sample(range(len(individual)), 2)",
      "        individual[i], individual[j] = individual[j], individual[i]",
      "    return individual",
      "",
      "def genetic_algorithm():",
      "    population = initial_population()",
      "    best_solution = min(population, key=fitness)",
      "    for _ in range(GENERATIONS):",
      "        new_population = []",
      "        for _ in range(POP_SIZE // 2):",
      "            parent1, parent2 = roulette_wheel_selection(population)",
      "            child1, child2 = crossover(parent1, parent2)",
      "            new_population.extend([mutate(child1), mutate(child2)])",
      "        population = new_population",
      "        best_candidate = min(population, key=fitness)",
      "        if fitness(best_candidate) < fitness(best_solution):",
      "            best_solution = best_candidate",
      "    return best_solution",
      "",
      "best_arrangement = genetic_algorithm()",
      "print(\"Best Book Arrangement:\", best_arrangement)",
      "print(\"Total Width:\", fitness(best_arrangement))"
    ],
    "description": "Genetic Algorithm for Optimal Book Arrangement"
  }
}
